{
  "_id": { "$oid": "68627c3ac6ce8cf75ea7543b" },
  "name": "google search",
  "description": "Performs a Google search using Google Custom Search API if credentials exist, otherwise falls back to DuckDuckGo (ddgs). Automatically returns text, image, video, or news results based on the query.",
  "type": "atomic",
  "execution_mode": "sandboxed",
  "code": "import os, sys, json, re, asyncio, random, importlib, subprocess\nfrom typing import List, Dict\n\n# ───────── Ensure dependencies ─────────\n\ndef _ensure(pkg: str, upgrade: bool = False):\n    try:\n        importlib.import_module(pkg)\n    except ImportError:\n        cmd = [sys.executable, '-m', 'pip', 'install']\n        if upgrade:\n            cmd.append('--upgrade')\n        cmd += [pkg, '--quiet']\n        subprocess.check_call(cmd)\n\nfor _p in ('ddgs', 'aiohttp', 'trafilatura', 'google-api-python-client'):\n    _ensure(_p, upgrade=True)\n\nfrom aiohttp import ClientSession, ClientTimeout\nimport trafilatura\nfrom ddgs import DDGS\n\nUA_LIST = [\n    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0 Safari/537.36',\n    'Mozilla/5.0 (Macintosh; Intel Mac OS X 13_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15',\n    'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:126.0) Gecko/20100101 Firefox/126.0'\n]\n\ndef _random_ua():\n    return random.choice(UA_LIST)\n\ndef _normalise_ws(t: str) -> str:\n    return re.sub(r\"\\s+\", \" \", (t or '')).strip()\n\ndef _strip_links_images(t: str) -> str:\n    if not t:\n        return ''\n    return re.sub(r'!\\[.*?\\]\\([^)]*\\)', '', t)\n\nasync def _fetch(session: ClientSession, url: str, timeout_sec: int = 10) -> str:\n    try:\n        async with session.get(url, timeout=timeout_sec) as r:\n            if r.status == 200:\n                return await r.text()\n    except Exception:\n        return ''\n    return ''\n\n# ───────── DuckDuckGo Universal ─────────\nasync def duckduckgo_search(query: str, num_results: int, timeout_sec: int = 10) -> List[Dict[str, str]]:\n    results: List[Dict[str, str]] = []\n    sem = asyncio.Semaphore(5)\n    timeout = ClientTimeout(total=timeout_sec)\n\n    def _pick_mode(q: str) -> str:\n        q_lower = q.lower()\n        if any(w in q_lower for w in ['video', 'youtube', 'trailer', 'watch', 'clip']):\n            return 'videos'\n        if any(w in q_lower for w in ['image', 'photo', 'picture', 'wallpaper', 'art']):\n            return 'images'\n        if any(w in q_lower for w in ['news', 'headline', 'article', 'press release']):\n            return 'news'\n        return 'text'\n\n    mode = _pick_mode(query)\n\n    async with ClientSession(timeout=timeout, headers={'User-Agent': _random_ua(), 'Accept-Language': 'en-US,en;q=0.9'}) as session:\n        ddgs = DDGS()\n        with ddgs:\n            if mode == 'videos':\n                hits = list(ddgs.videos(query, max_results=num_results))\n            elif mode == 'images':\n                hits = list(ddgs.images(query, max_results=num_results))\n            elif mode == 'news':\n                hits = list(ddgs.news(query, max_results=num_results))\n            else:\n                hits = list(ddgs.text(query, max_results=num_results))\n\n            async def _process(hit: Dict[str, str]):\n                async with sem:\n                    url = hit.get('url') or hit.get('href') or hit.get('content') or hit.get('link') or None\n                    if isinstance(url, dict):\n                        url = url.get('value')\n                    title = hit.get('title') or hit.get('source') or 'Untitled'\n                    snippet = hit.get('description') or hit.get('body') or hit.get('content') or ''\n                    entry = {\n                        'title': _normalise_ws(title),\n                        'url': url,\n                        'content': _normalise_ws(snippet),\n                        'type': mode\n                    }\n                    if mode == 'text' and url:\n                        try:\n                            html = await _fetch(session, url, timeout_sec)\n                            extracted = trafilatura.extract(html, include_comments=False, include_tables=False)\n                            entry['content'] = _strip_links_images(_normalise_ws(extracted or entry['content']))\n                        except Exception:\n                            pass\n                    results.append(entry)\n\n            await asyncio.gather(*(_process(h) for h in hits))\n\n    return [r for r in results if r.get('url')]\n\n# ───────── Google API Search ─────────\nasync def google_search(query: str, num_results: int = 5, timeout_sec: int = 10) -> List[Dict[str, str]]:\n    try:\n        from googleapiclient.discovery import build\n        api_key = os.getenv('GOOGLE_API_KEY')\n        cse_id = os.getenv('GOOGLE_CSE_ID')\n        if not api_key or not cse_id:\n            raise Exception('Google API key or CSE ID not found')\n\n        service = build('customsearch', 'v1', developerKey=api_key)\n        res = service.cse().list(q=query, cx=cse_id, num=num_results).execute()\n        items = res.get('items', [])\n        results: List[Dict[str, str]] = []\n        for item in items:\n            results.append({\n                'title': _normalise_ws(item.get('title', 'Untitled')),\n                'url': item.get('link'),\n                'content': _normalise_ws(item.get('snippet', '')),\n                'type': 'text'\n            })\n        return results\n    except Exception as e:\n        print(f\"⚠️ Google search failed: {e}. Using DuckDuckGo...\")\n        return await duckduckgo_search(query, num_results, timeout_sec)\n\n# ───────── Entrypoint ─────────\ndef _execute_action() -> None:\n    input_data = globals().get('input_data', {}) or {}\n    query = str(input_data.get('query', '')).strip()\n    num_results = int(input_data.get('num_results', 5))\n    if not query:\n        print(json.dumps({'error': \"The 'query' field is required.\"}, ensure_ascii=False))\n        return\n\n    try:\n        results = asyncio.run(google_search(query, num_results))\n        print(json.dumps({'message': f\"✅ Search complete: {len(results)} results found.\", 'search_results': results}, ensure_ascii=False))\n    except Exception as e:\n        print(json.dumps({'error': str(e)}, ensure_ascii=False))\n\n_execute_action()",
  "input_schema": {
    "query": {
      "type": "string",
      "example": "latest AI developments 2025",
      "description": "The query to search for."
    },
    "num_results": {
      "type": "integer",
      "example": 5,
      "description": "Number of results (1–20)."
    }
  },
  "output_schema": {
    "search_results": {
      "type": "array",
      "description": "List of search‐result objects containing {title, url, content, type}."
    }
  },
  "subActions": [],
  "default": true,
  "scope": ["global"]
}
